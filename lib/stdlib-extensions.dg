%% Things that don't exist in stdlib, but should.

(understand [throw/toss | $Words] as [throw $A at $B])
	*(split $Words by [through] into $Left and $Right)
	*(understand $Left as object $A preferably held)
	*(understand $Right as single object $B preferably { (window $_) })
    
%% Identify rooms that are adjacent to the current room
(adjacent room $Neighbor)
    (current room $Room)
    *(from $Room go $ to $Neighbor)

(collect items in $Container into $Items)
    (collect $Obj)
        *($Obj is #in $Container)
        %% Exclude non-items, including #knock (in the pickup truck)
        (item $Obj)
    (into $Items)

(select random item in $Container into $Object)
    (collect $Obj)
        *($Obj is #in $Container)
    (into $List)
    (randomly select $Object from $List)

(shuffle list [] into [])

(shuffle list [$X] into [$X])

(shuffle list $List into $Shuffled)
    (randomly select $Elem from $List)
    %% Side-effect (unwanted): makes elements distinct
    (remove from $List matching [$Elem] into $More)
    (shuffle list $More into $MoreShuffled)
    ($Shuffled = [$Elem | $MoreShuffled])

($X <= $Y)
    ($X < $Y) (or) ($X = $Y)

($X >= $Y)
    ($X > $Y) (or) ($X = $Y)

(random chance of $Y in $X)
    (random from 1 to $X into $Z)
    ($Z <= $Y)

%% Like @tree, but rooted in current room, and shows relations and other details
%% about the room and items.
(tree)
    (current room $Room)
    (log) {
        $Room 
        (annotate [{ (inherently dark $Room) dark }
                   { (office interior $Room) office interior }
                   { (around the tower $Room) around the tower } 
                   { (in range of headlights $Room) in range of headlights }])
        (line)
        (exhaust) {
            *($Obj has parent $Room)
            (tree $Obj 4)
        }
    }

(tree $Obj $Indent)
    ($Obj has relation $Rel)
    (space $Indent)
    $Obj $Rel
    (annotate [{ ($Obj is handled) handled }
               { (animate $Obj) animate }
               { ($Obj is hidden) hidden }
               { ($Obj is closed) closed }
               { ($Obj is locked ) locked }
               { ($Obj is off) off }
               { ($Obj is broken) broken }
               { ($Obj provides light) lit}])
    (line)
    ($Indent plus 4 into $ChildIndent)
    (exhaust) {
        *($Child has parent $Obj)
        (tree $Child $ChildIndent)
    }

%% So much of the trace output is understanding the players input, it obscures
%% the game-specific rules, so these predicates make it easy to start tracing
%% right at the point the action is processed via (try $) or (instead of $).

(trace $Action)
    (trace on)
    (stoppable) { (try $Action ) }
    (trace off)

(trace instead $Action)
    (trace on)
    (stoppable) { (instead of $Action) }
    (trace off)

($X incremented into $Z)
    ($X plus 1 into $Z)

($X decremented into $Z)
    ($X minus 1 into $Z)

%% Playtester kept trying this
(grammar [open [single] with [single]] for [unlock $ with $])